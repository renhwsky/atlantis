---
layout: post
title:  RCU锁机制
date: 2019-06-26
categories: 分布式文件系统 cephfs RCU
tags: 文件系统
excerpt: RCU锁机制
---

为什么需要RCU锁：  
---
RCU是2.6内核引入的新锁机制，为什么在已经存在自旋锁（spinlock）和读写锁（rwlock）的情况下，还需要引入新的锁机制？
有下面3个原因：
（1）这是因为随着CPU的速度越来越快，与访问内存的速度差距也越来越大（访问内存的速度变化较小），这自旋锁和读写锁是基于原    
     子的访问内存空间，因此加锁的应用在内存访问速度没有变化的情况下，越来越快的CPU，并没有提高加锁应用程序的性能；        
（2）另外在大部分非x86操作系统中，获取锁使用的是memory barrier技术，这会导致高速CPU流水线停滞和刷新；    
（3）老的锁机制在多核系统下，无法发挥其性能，比如rwlock在2核场景比在单核下要差。    
正是在这种情况下，新的RCU锁机制呼之欲出。


RCU锁：
---
RCU锁首先是一种高性能锁，且有好的扩展性，但它的应用场景比较窄，只适合读多写少的场景。   
RCU（Read-Copy-Update）顾名思义读-拷贝修改，被RCU保护的共享数据,读操作不需要获取任何锁就可以访问，但写者在访问它时，
首先会拷贝一个副本，然后对副本进行修改，再使用callback机制在适当的时候，把指向原来数据的部分指向新修改的数据。
这个时机就是所有引用该数据的CPU都退出对共享数据的操作。
可以看到RCU锁的优势是读没有锁开销，因此读的性能很高，但写的开销就比较大，它需要延迟数据结构的释放，复制被修改的数据结构，
它也必须使用某种锁机制同步并行的其它写者的修改操作。读者必须提供一个信号给写者以便写者能够确定数据可以被安全地释放或修改
的时机

RCU与rwlock的区别在于，RCU不但允许多个读者访问共享数据，还允许多个读者和写者同时访问共享数据空间（多写，需要其它锁来保存写是顺序性）
因此读操作不会受到写锁的影响，在一次写多读的情况下，性能会有显著的提示，但是如果有多写的情况下，则RCU的性能会由于写锁开销大，导致
整体性能下降。
rwlock锁的最大特点是排它性，即有写锁时，读锁时阻塞等待的，有读时，不能有写，这样性能比较差，但数据一致性比RCU要好，rwlock的改进锁
seqlock（顺序锁）则是在rwlock的基础上进行改进，它只对写加锁，且写加锁时，读可以继续操作，但存在在写完成后读取会被回滚丢弃，重新读
取新的值，也就是说seqlock仍然是一个顺序读写的屏障，所以叫做顺序锁。因为seqlock只有写操作需要加锁，写操作发生的时候不需要等待读的锁
释放。而rwlock则是读写互斥，当写入发生的时候需要等待读取结束。 



参考：
---
https://www.ibm.com/developerworks/cn/linux/l-rcu/index.html
https://zhuanlan.zhihu.com/p/56404913


